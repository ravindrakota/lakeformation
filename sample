-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAmVaV80vV14hawAq60bPdrIZ3ZSVvU1KXSH8eFs5r4EGKtdeciY+T+PaSjyYB
FHwcKbvDJM/dJTR9o8SR+srZIQ1PRrmHQ5SoKrLf1/pJ/ttPHvs0BO+tLvVKG4RV5gyNuyjVCixD
MrXNR5hFVgUiRQJl7LCkK0bWtaGHTlQsowXG2otYo2YUUwg35sjL1G90i2LgXygHbJWAtBG+uJ0V
cZrED5jt+mo4JDEwtyte4aU6QgcYXiP+l0p0EzPwGfZ+Sw0GZRdW3zUKpvsBct/npQV6dCA8pfU7
yUYppiA8eDc6pFV7vx8Yh2y1/WdTI4yzDPJyOU3h53ra4J1lvSj/OQIDAQABAoIBABl498oF9A0s
+p5iaeyCK7YIVHc6A8dctgL2EwKI4gTL/oX8vmVfs54tH+Wl05Ial/ca2O0Zlswibyiwc+usnOtP
sba3BVBltpX5RxQy4O30cq1b36VeR2/AkcIGdtqThUvtGY7qEXOwHdzh38rNaYb7QgFSysLhrrNX
lQmfFBc0kTuelVsRpbELqPbfXcgdEJ/scauTIKdje60eFhFg47v2zAs4OVYSYtSwop5OSeD3oDKD
MK2xC9veLVuEWNQSkkj1c4wYgX13p1X+94s3AkwA8x9C6rldhNg2kusWevejLzFPl2j+zy4pDqZM
0XDrteoRa73pgvYwFA38exWBBgECgYEA3WCpQBhWXiLhuuz6DWVGsFy0JIzW8psr0uAghoWlK6rY
dAAwMtlqY9cmU9luRkqXVtrWmyNJ5IlgeW+JDvkLT3GD69aOZ0z/QURpTbiZY1zM1OwxY7kXjM8D
toGXhn88HEAURpOdwZ/1323fCg81bILdgdauRESILriAEF9aAnkCgYEAsVHRtP3ttzTYTY75dDY8
GeprQdo+7ERq/onOrDUn/0ugMX3BXeNH5yJUXHS/49Fno3DkRl+0j15/H/a0ELwylmTpMdi4oe13
NUDXsP7mkQDHciW2gepwMjGOKaUfz/P+CdodBpkNmRj6zgQ/C2hamE3CgJ0xDfioFFjS1qv9ssEC
gYEAsFYtmwOH0GZCni3jpEX2v8aoK7EQCqG1j7y9y8mq3pSw4/2+ZtKuHycivYmlgFIsKKAab+r1
EhingzNn3khcTQSjy3jVZ816SZfftWwEqpQiCLy3PrMR4jSHxZmGhDjXPb2BKRKuh6wOItIW5qFk
sbGwFZtWpsRcIbMPN3tsbCkCgYBjWpXnFNTKb5i3NGI/pFfeqYO5nUDef6N3xd2AjjRADq7OrEjZ
g4z5TDn6qAwQ6Xdpk8rER8HTBz6xuTjBm8G4lQg4vtcNHBJMS23PpbOpEcevBMSTXLnK1gty+Cuw
CGWSPZ0/4ihFXULChoyQpsMETaWrDOi8jFQZOn/AexQmwQKBgGO96uOZK+BoRiJfLHXtDvmaPXtR
Ri4nkJd4pDTaKisp9GzSTKDo2BTTMXyILpqtehaYOB/0//3GzM1ZTX8OaNUrj40cBML45Fi6dQL5
nc+wZmZrPE6qJVjSi8QaeA3h+sL48KZXoBEQl1DgKMma03WwjUnMiln9kPke60HNhawR
-----END RSA PRIVATE KEY-----


import org.apache.log4j.Logger;
import org.codehaus.jackson.JsonParseException;
import org.codehaus.jackson.map.DeserializationConfig;
import org.codehaus.jackson.map.JsonMappingException;
import org.codehaus.jackson.map.ObjectMapper;
import java.io.IOException;
import java.util.Collection;

/**
 * JsonUtils used to change JSON strings into deserialized objects.
 */
public class JsonUtils {
    static Logger log = Logger.getLogger(JsonUtils.class);

    public static <T> T convertFromJson(String json, Class<T> valueType) {
        ObjectMapper om = new ObjectMapper();
        om.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);
        om.setVisibilityChecker(om.getSerializationConfig().getDefaultVisibilityChecker()
            .withFieldVisibility(org.codehaus.jackson.annotate.JsonAutoDetect.Visibility.ANY)
            .withGetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect.Visibility.NONE)
            .withSetterVisibility(org.codehaus.jackson.annotate.JsonAutoDetect.Visibility.NONE)
            .withCreatorVisibility(org.codehaus.jackson.annotate.JsonAutoDetect.Visibility.NONE));

        T id = null;
        try {
            id = om.readValue(json, valueType);
            return id;
        } catch (JsonParseException e) {
            log.error("convertFromJson", e);
        } catch (JsonMappingException e) {
            log.error("convertFromJson", e);
        } catch (IOException e) {
            log.error("convertFromJson", e);
        }
        return null;
    }

    public static String convertToJson(Object ld) {
        try {
            String json;
            json = new ObjectMapper().writeValueAsString(ld);
            return json;
        } catch (IOException e) {
            log.error("convertToJson", e);
        }
        return null;
    }

    public static <T> T  convertFromJsonArray(String json , Class<? extends Collection> collectionClass, Class<?> elementClass){
        if(json != null && !json.isEmpty()){
            ObjectMapper om = new ObjectMapper();
            try {
                T id = om.readValue(json,
                        om.getTypeFactory().constructCollectionType(
                                collectionClass, elementClass));
                return id;

            } catch (JsonParseException e) {
                log.error("convertFromJsonArray",e);
            } catch (JsonMappingException e) {
                log.error("convertFromJsonArray",e);
            } catch (IOException e) {
                log.error("convertFromJsonArray",e);
            }
        }
        return null;
    }
}


public class SparkContextManager {

    private static SparkSession sparkSession = null;

    public static void stopSparkContext(){
        if (sparkSession != null) {
            sparkSession.stop();
        }
    }

    public static synchronized void setSparkSession(SparkSession spark) {
        sparkSession = spark;
    }

    public static synchronized SparkSession getSparkSession() {
        if (sparkSession == null) {
            sparkSession = SparkSession.builder().getOrCreate();
            sparkSession.sql("set spark.sql.caseSensitive=false");
        }
        return sparkSession;
    }
}


import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.permission.FsPermission;
import org.apache.log4j.Logger;

/**
 * Utils class that validates files from different log paths

 */
public class OutputUtils {
	static final Logger logger = Logger.getLogger(OutputUtils.class);

	public static void moveEdgeLogToHdfs(String localLogPath, String hdfsLogPath)
			throws IOException {
		Path localLgPath = new Path(localLogPath);
		Path hdfsLgPath = new Path(hdfsLogPath);
		FileSystem fs = FileSystem.get(new Configuration());
		FsPermission fileper = new FsPermission((short) 0755);
		if (!fs.exists(hdfsLgPath)) {
			logger.info("Hdfs log directory doesn't exists. Creating "
					+ hdfsLgPath);
			fs.mkdirs(hdfsLgPath, fileper);
		}
		fs.moveFromLocalFile(localLgPath, hdfsLgPath);
	}

	public static void validateOutputParent(String outputParent)
			throws IOException {
		Path outParentPath = new Path(outputParent);
		FileSystem fs = FileSystem.get(new Configuration());
		FsPermission fileper = new FsPermission((short) 0755);
		if (!fs.exists(outParentPath))
		{
			logger.info("DataProfiling directory doesn't exist. Creating "
					+ outParentPath);
			fs.mkdirs(outParentPath, fileper);
		}
	}



import org.apache.hadoop.yarn.api.records.ApplicationId;
import org.apache.hadoop.yarn.logaggregation.*;

import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.io.PrintStream;

import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.permission.FsPermission;
import org.apache.log4j.ConsoleAppender;
import org.apache.log4j.Level;
import org.apache.log4j.Logger;
import org.apache.log4j.PatternLayout;
import org.apache.log4j.RollingFileAppender;


public class LogUtils {
	static final Logger logger = Logger.getLogger(LogUtils.class);
	public static void createLogger(String filePath)
	{
		logger.info("Edge node log file is "+filePath);
		// creates pattern layout
		PatternLayout layout = new PatternLayout();
		String conversionPattern = "%d{dd MMM yyyy HH:mm:ss},%m%n";
		layout.setConversionPattern(conversionPattern);
		// creates file appender
		RollingFileAppender rollfileAppender = new RollingFileAppender();
		rollfileAppender.setFile(filePath);
		rollfileAppender.setMaxFileSize("200MB");
		rollfileAppender.setMaxBackupIndex(1);
		rollfileAppender.setLayout(layout);
		rollfileAppender.activateOptions();
		// creates console appender
		ConsoleAppender consoleappender = new ConsoleAppender();
		consoleappender.setLayout(layout);
		consoleappender.setThreshold(Level.DEBUG);
		consoleappender.activateOptions();
		// configures the root logger
		Logger rootLogger = Logger.getRootLogger();
		// rootLogger.addAppender(consoleappender);
		rootLogger.addAppender(rollfileAppender);
		rootLogger.setLevel(Level.INFO);
	}
	
	public static void LogConfig(long clusterTimestamp, int appId,
			Configuration conf,String hdfslogPath, String hdfsLogFileName) throws IOException, InterruptedException {
		Path hdfsLgPath = new Path (hdfslogPath);
		FileSystem fs = FileSystem.get(conf);
		FsPermission fileper = new FsPermission((short) 0775);
		if(!fs.exists(hdfsLgPath))
		{
			logger.info("Hdfs log directory doesn't exists. Creating "+hdfsLgPath);
			fs.mkdirs(hdfsLgPath,fileper);
		}
		try {
			Thread.sleep(10000); // Sleep, Since Yarn takes time to aggregate
									// logs from all containers.
		}
		catch (InterruptedException ex) {
			Thread.currentThread().interrupt();
		}
				ApplicationId app = ApplicationId.newInstance(clusterTimestamp, appId);
		LogCLIHelpers lg = new LogCLIHelpers();
		lg.setConf(conf);
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream ps = new PrintStream(baos);
		lg.dumpAllContainersLogs(app, System.getenv("USER"), ps);
		String LogContent = baos.toString();
		Path FullLogpath = new Path(hdfsLogFileName);
		BufferedWriter br = new BufferedWriter(new OutputStreamWriter(
				fs.create(FullLogpath, true)));
		br.write(LogContent);
		br.append('\n');
		br.close();
	}
}


import java.io.IOException;
import org.apache.hadoop.conf.Configuration;
import org.apache.hadoop.fs.FileSystem;
import org.apache.hadoop.fs.Path;
import org.apache.hadoop.fs.permission.FsPermission;
import org.apache.log4j.Logger;

/**
 * Utils class that validates files from different log path
 */
public class OutputUtils {
	static final Logger logger = Logger.getLogger(OutputUtils.class);

	public static void moveEdgeLogToHdfs(String localLogPath, String hdfsLogPath)
			throws IOException {
		Path localLgPath = new Path(localLogPath);
		Path hdfsLgPath = new Path(hdfsLogPath);
		FileSystem fs = FileSystem.get(new Configuration());
		FsPermission fileper = new FsPermission((short) 0755);
		if (!fs.exists(hdfsLgPath)) {
			logger.info("Hdfs log directory doesn't exists. Creating "
					+ hdfsLgPath);
			fs.mkdirs(hdfsLgPath, fileper);
		}
		fs.moveFromLocalFile(localLgPath, hdfsLgPath);
	}

	public static void validateOutputParent(String outputParent)
			throws IOException {
		Path outParentPath = new Path(outputParent);
		FileSystem fs = FileSystem.get(new Configuration());
		FsPermission fileper = new FsPermission((short) 0755);
		if (!fs.exists(outParentPath))
		{
			logger.info("DataProfiling directory doesn't exist. Creating "
					+ outParentPath);
			fs.mkdirs(outParentPath, fileper);
		}
	}
	
	public static void validateLogLocation(String logLocation)
			throws IOException {
		Path logLoc = new Path(logLocation);
		FileSystem fs = FileSystem.get(new Configuration());
		FsPermission fileper = new FsPermission((short) 0755);
		if (!fs.exists(logLoc))
		{
			logger.info("Log directory doesn't exist. Creating "
					+ logLoc);
			fs.mkdirs(logLoc, fileper);
		}
	}
}


import org.apache.http.conn.ClientConnectionManager;
import org.apache.http.conn.scheme.PlainSocketFactory;
import org.apache.http.conn.scheme.Scheme;
import org.apache.http.conn.scheme.SchemeRegistry;
import org.apache.http.conn.ssl.SSLSocketFactory;
import org.apache.http.impl.conn.SingleClientConnManager;

import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManager;
import javax.net.ssl.X509TrustManager;
import java.security.SecureRandom;
import java.security.cert.X509Certificate;

public class SSLUtils {

    public static ClientConnectionManager bypassSSL() throws Exception{
        SSLContext sslContext = SSLContext.getInstance("SSL");

        // set up a TrustManager that trusts everything
        sslContext.init(null, new TrustManager[] { new X509TrustManager() {
            public X509Certificate[] getAcceptedIssuers() {
                return null;
            }

            public void checkClientTrusted(X509Certificate[] certs,
                                           String authType) {
            }

            public void checkServerTrusted(X509Certificate[] certs,
                                           String authType) {
            }
        } }, new SecureRandom());

        SSLSocketFactory sf = new SSLSocketFactory(sslContext);
        Scheme httpsScheme = new Scheme("https", 443, sf);
        SchemeRegistry schemeRegistry = new SchemeRegistry();
        schemeRegistry.register(httpsScheme);
        schemeRegistry.register(new Scheme("http", 80, PlainSocketFactory.getSocketFactory()));


// apache HttpClient version >4.2 should use BasicClientConnectionManager
        ClientConnectionManager cm = new SingleClientConnManager(schemeRegistry);
        return cm;
    }
}

import com.google.common.base.Throwables;

import java.io.PrintWriter;
import java.util.logging.ConsoleHandler;
import java.util.logging.Formatter;
import java.util.logging.Level;
import java.util.logging.LogRecord;

public class ConsoleLogger {
    static final java.util.logging.Logger consoleLog = java.util.logging.Logger.getLogger(ConsoleLogger.class + "");
    static final PrintWriter stdoutWriter = new PrintWriter(System.out, true);
    static final StringBuilder outputErrorLogsCollector;

    static {
        consoleLog.setLevel(Level.ALL);
        ConsoleHandler handler = new ConsoleHandler();
        handler.setFormatter(new MyFormatter());
        handler.setLevel(Level.ALL);
        consoleLog.addHandler(handler);
        outputErrorLogsCollector = new StringBuilder();
    }

    public static void consoleLog(String mesg) {
        stdoutWriter.println(mesg);
        outputErrorLogsCollector.append(mesg).append("\n");
    }

    public static void consoleLog(String mesg, Exception e) {
        mesg = !mesg.endsWith(": ") ? mesg + ": " : mesg; // formats messages ending with or without ": " properly
        stdoutWriter.println(mesg + e.getMessage());
        String stackTrace = Throwables.getStackTraceAsString(e);
        stdoutWriter.println(stackTrace);
        outputErrorLogsCollector.append(mesg).append("\n").append(stackTrace).append("\n");
    }

    public static void consoleLog(Exception e) {
        String stackTrace = Throwables.getStackTraceAsString(e);
        stdoutWriter.println(e.getMessage() + "\n" + stackTrace);
        outputErrorLogsCollector.append(e.getMessage()).append("\n").append(stackTrace).append("\n");
    }

    public static String getOutputErrorLogs() {
        return outputErrorLogsCollector.toString();
    }

    public static void clear() { // used for testing purposes
        outputErrorLogsCollector.setLength(0);
    }

    static class MyFormatter extends Formatter {
        @Override
        public String format(LogRecord record) {

            return record.getMessage() + "\n";
        }
    }
}

